**Java Core** — это термин, который может использоваться по-разному в разных контекстах. Если он встречается в вакансиях на разработчика уровня Junior, то под ним обычно подразумевается базовое знание языка Java. Однако компания **Sun Microsystems**, в которой разработали язык Java, определяет **Core Java** как вычислительную платформу, основанную на Java.

Существуют три вычислительные платформы, основанные на Java:

1. **Java Standard Edition (Java SE) или Core Java**: Это базовое API, обычно используется для разработки десктопных приложений.
2. **Java Enterprise Edition (Java EE)**: Корпоративная версия Java, применяется для разработки более мощных серверных приложений и веб-сайтов.
3. **Java Micro Edition (Java ME)**: Используется для разработки приложений для устройств с ограниченными ресурсами, таких как мобильные телефоны, принтеры и проигрыватели Blu-ray.

Исторически Java была разработана в 1995 году Джеймсом Гослингом в компании Sun Microsystems. Изначально язык назывался **Oak**, затем получил новое название — **Green**, а в итоге стал называться **Java** в честь кофе с острова Ява в Индонезии (однако название языка читается «джава»). Java была предназначена для интерактивного телевидения, но оказалась слишком продвинутой для этой индустрии.

Где применяется Java? Java — это язык широкого назначения. Его основной принцип: «Пиши один раз, запускай где угодно», или **WORA** (Write Once, Run Anywhere). Это значит, что скомпилированный Java-код можно запустить на всех поддерживающих Java платформах без необходимости повторной компиляции. Java-приложения обычно компилируются в байт-код (набор инструкций, выполняемый виртуальной машиной Java). **JVM** (Java Virtual Machine) устанавливается на платформу, на которой предстоит выполнение Java-программы. 

---
# I. Основы языка

В этой главе мы рассмотрим основы языка Java.
## 1.1. Синтаксис

Java - это строго типизированный объектно-ориентированный язык программирования. Вот основной синтаксис:

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Привет, мир!");
    }
}
```

В этом примере `public` - это модификатор доступа, `class` указывает на то, что это класс, `Main` - это имя класса, `public static void main(String[] args)` - это основной метод, который выполняется при запуске программы, и `System.out.println("Привет, мир!");` - это команда вывода на экран.

---
## 1.2. Переменные

В Java есть три типа переменных: локальные, переменные экземпляра (instance variables) и статические переменные (static variables).

```java
public class Main {
    static int staticVar = 10; // статическая переменная
    int instanceVar = 20; // переменная экземпляра

    public void method() {
        int localVar = 30; // локальная переменная
        System.out.println(localVar);
    }
}
```

### 1.2.1. Локальные переменные

Локальные переменные — это переменные, объявленные внутри метода, блока кода или конструктора. Они существуют только в пределах этого блока и уничтожаются после завершения выполнения блока. Вот некоторые ключевые моменты:

- Локальные переменные объявляются внутри методов или блоков кода.
- Их область видимости ограничена только этим методом или блоком.
- Локальные переменные не имеют значения по умолчанию и должны быть явно инициализированы перед использованием.

Пример:

```java
public class Example {
    public void someMethod() {
        int localVar = 42; // Локальная переменная
        System.out.println(localVar);
    }
}
```

### 1.2.2. Переменные экземпляра (instance variables)

Переменные экземпляра — это нестатические переменные, объявленные внутри класса, но вне методов или блоков кода. Они существуют на уровне объекта и инициализируются при создании экземпляра класса. Важные моменты:

- Переменные экземпляра объявляются внутри класса, но не внутри методов.
- Они связаны с конкретным объектом класса.
- Их значения могут быть разными для разных объектов.

Пример:

```java
public class Example {
    int instanceVar = 100; // Переменная экземпляра

    public void printInstanceVar() {
        System.out.println(instanceVar);
    }
}
```

### 1.2.3. Статические переменные (static variables)

Статические переменные объявляются с ключевым словом `static` и существуют на уровне класса, а не на уровне объекта. Важные моменты:

- Статические переменные создаются только один раз на уровне класса.
- Они общие для всех объектов этого класса.
- Их значения могут быть общими для всех экземпляров.

Пример:

```java
public class Example {
    static int staticVar = 500; // Статическая переменная

    public static void main(String[] args) {
        System.out.println(staticVar);
    }
}
```

Таким образом, разница между статическими переменными и переменными экземпляра заключается в их области видимости, связи с объектами и общности значений. 

---
## 1.3. Типы данных

В Java существуют два основных типа данных: примитивные и ссылочные.

```java
int num = 10; // примитивный тип
String str = "Привет"; // ссылочный тип
```

### 1.3.1. Примитивные типы данных

Примитивные типы данных включают `byte`, `short`, `int`, `long`, `float`, `double`, `boolean` и `char`. Они называются “примитивными”, потому что они содержат простые значения. Когда вы объявляете переменную примитивного типа, вы резервируете место в памяти для хранения значения, и это значение является фактическим значением переменной.

```java
int num = 10; // num содержит фактическое значение 10
```

### 1.3.2. Ссылочные типы данных

Ссылочные типы данных включают классы, интерфейсы и массивы. Когда вы создаете переменную ссылочного типа, вы резервируете место в памяти, которое содержит ссылку на объект, а не сам объект. Эта ссылка указывает на место в памяти, где хранится фактический объект.

```java
String str = "Привет"; // str содержит ссылку на объект String, а не саму строку "Привет"
```

### 1.3.3. Основные различия

1. **Присваивание и сравнение**: Для примитивных типов используются операторы `==` и `!=` для проверки равенства или неравенства значений. Для ссылочных типов эти операторы сравнивают, указывают ли ссылки на один и тот же объект, а не равны ли сами объекты.
2. **Значение по умолчанию**: Примитивные типы имеют значения по умолчанию (например, 0 для `int`, `false` для `boolean`), поэтому они никогда не могут быть `null`. Ссылочные типы могут быть `null`, что означает, что они не указывают ни на какой объект.
3. **Методы**: Примитивные типы не имеют методов, в то время как ссылочные типы имеют методы, которые можно вызывать. Например, у класса `String` есть методы, такие как `length()`, `substring()`, и т.д.
4. **Размер**: Примитивные типы имеют фиксированный размер, в то время как размер ссылочных типов может варьироваться в зависимости от конкретного объекта.

Это основные различия между примитивными и ссылочными типами данных в Java. Для более глубокого понимания рекомендую изучить официальную документацию Oracle и книги по Java, такие как “Thinking in Java” Брюса Эккеля и “Effective Java” Джошуа Блоха.

---
## 1.4. Операторы

Java предоставляет большое количество операторов, включая арифметические (`+`, `-`, `*`, `/`, `%`), сравнения (`==`, `!=`, `<`, `>`, `<=`, `>=`), логические (`&&`, `||`, `!`) и другие.

```java
int a = 10;
int b = 20;
int c = a + b; // арифметический оператор
boolean result = a > b; // оператор сравнения
```

Конечно! Давай разберемся с логическими операторами в Java.

### 1.4.1. Логические операторы

Логические операторы используются для работы с булевыми значениями (логическими выражениями). Вот некоторые из них:

1. **Логическое И (`&&`)**: Возвращает `true`, если оба операнда истинны. Если хотя бы один операнд ложен, результат будет `false`.
    
    Пример:
    
    ```java
    boolean isSunny = true;
    boolean isWarm = true;
    boolean isNiceDay = isSunny && isWarm; // true
    ```
    
2. **Логическое ИЛИ (`||`)**: Возвращает `true`, если хотя бы один из операндов истинен. Если оба операнда ложны, результат будет `false`.
    
    Пример:
    
    ```java
    boolean hasUmbrella = false;
    boolean isRaining = true;
    boolean needUmbrella = hasUmbrella || isRaining; // true
    ```
    
3. **Логическое НЕ (`!`)**: Инвертирует значение операнда. Если операнд истинен, результат будет ложным, и наоборот.
    
    Пример:
    
    ```java
    boolean isCloudy = true;
    boolean isNotCloudy = !isCloudy; // false
    ```
    

#### 1.4.1.1. Примеры использования

1. **Проверка возраста**:
    
    ```java
    int age = 18;
    boolean isAdult = age >= 18; // true
    ```
    
2. **Проверка наличия прав**:
    
    ```java
    boolean hasDrivingLicense = true;
    boolean hasCar = false;
    boolean canDrive = hasDrivingLicense && hasCar; // false
    ```
    
3. **Проверка допустимости действия**:
    
    ```java
    boolean isWeekend = true;
    boolean isBankOpen = false;
    boolean canWithdrawMoney = isWeekend || isBankOpen; // true
    ```
    

Логические операторы позволяют создавать сложные условия и контролировать поток выполнения программы.

---
### 1.5. Управляющие конструкции

В этой главе мы рассмотрим основные управляющие конструкции в языке Java. Эти конструкции позволяют нам контролировать поток выполнения программы, принимать решения на основе условий и выполнять повторяющиеся действия.

Управляющие конструкции в Java включают условные операторы (`if`, `else`, `switch`), циклы (`for`, `while`, `do-while`) и операторы перехода (`break`, `continue`, `return`).

#### 1.5.1. Условные операторы

##### 1.5.1.1. Оператор `if`

Оператор `if` позволяет выполнять блок кода, если указанное условие истинно. Если условие ложно, блок кода не выполняется.

Пример:

```java
int a = 10;
int b = 20;

if (a > b) {
    System.out.println("a больше b");
} else {
    System.out.println("b больше или равно a");
}
```

##### 1.5.1.2. Оператор `else if`

Оператор `else if` позволяет проверить несколько условий последовательно. Если первое условие не выполняется, проверяется следующее условие.

Пример:

```java
int score = 75;

if (score >= 90) {
    System.out.println("Отлично!");
} else if (score >= 80) {
    System.out.println("Хорошо");
} else if (score >= 70) {
    System.out.println("Удовлетворительно");
} else {
    System.out.println("Неудовлетворительно");
}
```

#### 1.5.2. Циклы

##### 1.5.2.1. Цикл `for`

Цикл `for` позволяет выполнять блок кода определенное количество раз. Он состоит из инициализации, условия и инкремента.

Пример:

```java
for (int i = 0; i < 10; i++) {
    System.out.println(i);
}
```

##### 1.5.2.2. Цикл `while`

Цикл `while` выполняет блок кода, пока указанное условие истинно.

Пример:

```java
int count = 0;
while (count < 5) {
    System.out.println("Привет!");
    count++;
}
```

#### 1.5.3. Операторы перехода

##### 1.5.3.1. Оператор `break`

Оператор `break` используется для выхода из цикла или переключения на следующий блок кода.

Пример:

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;
    }
    System.out.println(i);
}
```

##### 1.5.3.2. Оператор `continue`

Оператор `continue` пропускает текущую итерацию цикла и переходит к следующей.

Пример:

```java
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) {
        continue;
    }
    System.out.println(i);
}
```

##### 1.5.3.3. Оператор `return`

Оператор `return` используется для возврата значения из метода или функции.

Пример:

```java
public int add(int a, int b) {
    return a + b;
}
```

Это лишь базовый обзор управляющих конструкций в Java. 

---
# II. Объектно-ориентированное программирование (ООП)

В этой главе мы рассмотрим основные концепции объектно-ориентированного программирования (ООП) в языке Java.
## 2.1. Классы и объекты

### 2.1.1. Классы

- **Класс** — это шаблон или чертеж для создания объектов. Он определяет состояние (поля) и поведение (методы) объектов.
- Классы объявляются с помощью ключевого слова `class`.

Пример:

```java
public class Person {
    String name;
    int age;

    public void sayHello() {
        System.out.println("Привет, меня зовут " + name);
    }
}
```

### 2.1.2. Объекты

- **Объект** — это экземпляр класса. Он создается на основе класса и имеет свои уникальные значения полей.
- Объекты создаются с помощью ключевого слова `new`.

Пример:

```java
public class Main {
    public static void main(String[] args) {
        Person person1 = new Person();
        person1.name = "Анна";
        person1.age = 30;
        person1.sayHello();
    }
}
```

---
## 2.2. Наследование

- **Наследование** позволяет создавать новый класс на основе существующего.
- Новый класс называется **подклассом**, а существующий — **суперклассом**.
- Подкласс наследует поля и методы суперкласса.

Пример:

```java
class Student extends Person {
    String university;

    public void study() {
        System.out.println(name + " учится в " + university);
    }
}
```

---
## 2.3. Инкапсуляция

- **Инкапсуляция** — это механизм, который скрывает детали реализации класса от внешнего мира.
- Инкапсуляция достигается с помощью модификаторов доступа (`private`, `protected`, `public`).

Пример:

```java
class BankAccount {
    private double balance;

    public void deposit(double amount) {
        balance += amount;
    }

    public double getBalance() {
        return balance;
    }
}
```

---
## 2.4. Полиморфизм

- **Полиморфизм** позволяет использовать один интерфейс для разных типов данных.
- Это достигается с помощью переопределения методов (полиморфизм на уровне методов) или с помощью перегрузки методов (полиморфизм на уровне параметров).

Пример:

```java
class Animal {
    void makeSound() {
        System.out.println("Звук животного");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Гав-гав!");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Мяу!");
    }
}
```

---
## 2.5. Абстрактные классы и интерфейсы

### 2.5.1. Абстрактные классы

- **Абстрактные классы** — это классы, которые не могут быть созданы напрямую, а только наследованы.
- Они предоставляют общий интерфейс для подклассов, но сами не могут быть инстанцированы.
- Вот некоторые свойства абстрактных классов:
    - Определяются с помощью ключевого слова `abstract`.
    - Могут содержать как абстрактные методы (методы без реализации), так и обычные методы с реализацией.
    - Могут иметь поля (переменные экземпляра).
    - Не могут быть инстанцированы (нельзя создать объект абстрактного класса напрямую).
    - Могут быть использованы как базовый класс для других классов.

Пример:

```java
abstract class Shape {
    abstract double area(); // Абстрактный метод
    void display() {
        System.out.println("Фигура");
    }
}

class Circle extends Shape {
    double radius;

    Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double area() {
        return Math.PI * radius * radius;
    }
}
```

### 2.5.2. Интерфейсы

- **Интерфейсы** — это контракты, которые определяют методы, которые должны быть реализованы классами.
- Вот некоторые свойства интерфейсов:
    - Определяются с помощью ключевого слова `interface`.
    - Могут содержать только абстрактные методы (без реализации).
    - Могут содержать константы (поля с `final static`).
    - Могут быть реализованы классами (классы могут реализовывать несколько интерфейсов).

Пример:

```java
interface Drawable {
    void draw(); // Абстрактный метод
}

class Circle implements Drawable {
    double radius;

    Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println("Рисуем круг");
    }
}
```

Абстрактные классы и интерфейсы используются для создания гибкой архитектуры приложений, обеспечивая разделение обязанностей и общий интерфейс для классов. 



---
# III. Исключения

В этой главе мы рассмотрим обработку исключений в языке Java. Исключения позволяют элегантно обрабатывать ошибки и исключительные ситуации в программе.
## 3.1. Обработка исключений

Исключения возникают в процессе выполнения программы, когда что-то идет не так. Например, это может быть деление на ноль, попытка доступа к несуществующему элементу массива или ошибка ввода-вывода.

### Конструкция `try...catch...finally`

- Для обработки исключений используется конструкция `try...catch...finally`.
- В блоке `try` помещаются инструкции, которые могут вызвать исключение.
- Если исключение возникает, управление переходит в блок `catch`, где можно обработать это исключение.
- Блок `finally` выполняется в любом случае, даже если исключение не возникло.

Пример:

```java
try {
    int[] numbers = new int[3];
    numbers[4] = 45;
    System.out.println(numbers[4]);
} catch (Exception ex) {
    ex.printStackTrace();
} finally {
    System.out.println("Блок finally");
}
```

### Обработка нескольких исключений

- В Java есть множество различных типов исключений.
- Мы можем разграничить их обработку, включив дополнительные блоки `catch`.

Пример:

```java
try {
    // ...
} catch (NullPointerException ex) {
    // Обработка NullPointerException
} catch (ArrayIndexOutOfBoundsException ex) {
    // Обработка ArrayIndexOutOfBoundsException
} catch (Exception ex) {
    // Обработка других исключений
}
```

## 3.2. Создание собственных исключений

- Чтобы создать свой класс исключений, нужно унаследовать его от класса `Exception`.
- Например, если у нас есть класс, вычисляющий факториал, и нам нужно выбросить специальное исключение, если число, передаваемое в метод, меньше 1:

```java
class NegativeNumberException extends Exception {
    NegativeNumberException(String message) {
        super(message);
    }
}

class FactorialCalculator {
    int calculateFactorial(int n) throws NegativeNumberException {
        if (n < 0) {
            throw new NegativeNumberException("Число должно быть неотрицательным");
        }
        // Вычисление факториала
        // ...
    }
}
```


---
# IV. Работа со строками в Java

## 4.1. Класс String
### 4.1.1. Основы класса String
Класс `String` в Java используется для работы со строками. Строки в Java неизменяемы, что означает, что однажды созданный объект `String` не может быть изменен.

```java
String greeting = "Hello, World!";
```

### 4.1.2. Методы класса String
Класс `String` предоставляет множество методов для работы со строками:
- `length()` возвращает длину строки.
- `charAt(int index)` возвращает символ по указанному индексу.
- `substring(int beginIndex, int endIndex)` возвращает подстроку.
- `concat(String str)` объединяет строки.
- `indexOf(String str)` возвращает индекс первого вхождения подстроки.
- `toLowerCase()` и `toUpperCase()` возвращают строку в нижнем или верхнем регистре соответственно.
- `equals(Object anObject)` сравнивает строки на равенство.
- `equalsIgnoreCase(String anotherString)` сравнивает строки на равенство без учета регистра.
- `startsWith(String prefix)` и `endsWith(String suffix)` проверяют начинается или заканчивается ли строка на определенную подстроку.

### 4.1.3. Сравнение строк
Для сравнения строк на равенство следует использовать `equals()` вместо оператора `==`, который сравнивает ссылки, а не содержимое строк.

```java
String str1 = "Hello";
String str2 = "Hello";
boolean isEqual = str1.equals(str2); // true
```

## 4.2. Класс StringBuilder
## 4.2.1. Понятие класса StringBuilder
`StringBuilder` используется, когда необходимо создать строку с возможностью изменения. Это увеличивает производительность при многократных операциях со строкой.

```java
StringBuilder sb = new StringBuilder("Hello");
```

## 4.2.2. Методы класса StringBuilder
- `append()` добавляет текст в конец строки.
- `insert(int offset, String str)` вставляет строку в указанную позицию.
- `delete(int start, int end)` удаляет часть строки.
- `reverse()` переворачивает строку.
- `toString()` конвертирует `StringBuilder` обратно в `String`.

```java
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");
String str = sb.toString(); // "Hello World"
```

## 4.3. Регулярные выражения
### 4.3.1. Основы регулярных выражений
Регулярные выражения представляют собой мощный инструмент для поиска и манипуляций с текстом, позволяя описывать шаблоны для сложных поисковых задач.

### 4.3.2. Классы Pattern и Matcher
- `Pattern` компилирует регулярное выражение в паттерн.
- `Matcher` используется для выполнения операций поиска с использованием паттерна.

```java
Pattern pattern = Pattern.compile("a*b");
Matcher matcher = pattern.matcher("aabtextaab");
while (matcher.find()) {
    System.out.println("Найдено совпадение: " + matcher.group());
}
```

### 4.3.3. Методы класса Matcher
- `find()` ищет следующее совпадение.
- `group()` возвращает найденный текст.
- `start()` и `end()` возвращают начальный и конечный индексы последнего совпадения.

### 4.3.4. Регулярные выражения в строковых методах
Многие методы класса `String` принимают регулярные выражения, такие как `split()`, `matches()

`, `replaceFirst()`, `replaceAll()`.

```java
String[] parts = "one:two:three".split(":");
boolean matches = "abc".matches("a*b"); // false
String replaced = "abc".replaceAll("a*b", "replacement"); // "replacementc"
```

Освоение работы со строками и регулярными выражениями в Java открывает широкие возможности для обработки текста и данных в приложениях.


---
# V. Коллекции в Java

Коллекции в Java - это фреймворк, предоставляющий архитектуру для хранения и манипулирования группой объектов. Коллекции играют ключевую роль в программировании, позволяя работать с наборами данных.

![[Pasted image 20240207121941.png]]
## 5.1. Интерфейсы коллекций

### 5.1.1. Основные интерфейсы
Java Collections Framework включает несколько основных интерфейсов: `Collection`, `List`, `Set`, `Map`, и `Queue`, каждый из которых имеет свои особенности и предназначение.

- **Collection** - корневой интерфейс для других интерфейсов коллекций, кроме `Map`. Определяет основные методы для работы с наборами данных.
- **List** - упорядоченная коллекция, которая может содержать дублирующиеся элементы. Предоставляет контроль над тем, где в списке будет храниться каждый элемент.
- **Set** - коллекция, не содержащая дублирующихся элементов. Это может быть использовано для создания наборов, где каждый элемент уникален.
- **Map** - объект, сохраняющий отношения ключ/значение. Ключи уникальны, а значения могут дублироваться.
- **Queue** - коллекция, предназначенная для хранения элементов перед их обработкой. Следует принципу FIFO (first-in-first-out), хотя некоторые реализации могут предоставлять различные порядки обработки.

### 5.1.2. Методы интерфейсов
Каждый интерфейс коллекций предоставляет различные методы для управления данными, такие как `add`, `remove`, `contains`, `size` и `clear`.

## 5.2. Реализации коллекций

### 5.2.1. Реализации List
- **ArrayList** - реализация на основе массива, обеспечивает быстрый доступ к элементам, но медленное добавление и удаление.
![[Pasted image 20240207121532.png]]

- **LinkedList** - реализация в виде связанного списка, обеспечивает быструю вставку и удаление.
![[singly_linkedlist-removebg-preview.png]]

### 5.2.2. Реализации Set
- **HashSet** - использует хеш-таблицу для хранения элементов. Обеспечивает высокую производительность операций.
- **TreeSet** - основан на красно-черном дереве, элементы автоматически сортируются.

### 5.2.3. Реализации Map
- **HashMap** - хеш-таблица для хранения пар ключ/значение. Не гарантирует порядок элементов.
- **TreeMap** - основан на красно-черном дереве, ключи сортируются в порядке возрастания.

### 5.2.4. Реализации Queue
- **LinkedList** - может быть использован как очередь, поддерживает обе стороны очереди.
- **PriorityQueue** - элементы упорядочиваются в соответствии с их приоритетами.

## 5.3. Класс Collections

### 5.3.1. Утилитные методы
Класс `Collections` содержит статические методы для работы с коллекциями, такие как сортировка, поиск, обращение порядка элементов, копирование и многое другое.

### 5.3.2. Примеры методов
- `Collections.sort(List<T> list)` - сортирует список.
- `Collections.shuffle(List<?> list)` - перемешивает список.
- `Collections.unmodifiableCollection(Collection<T> c)` - возвращает неизменяемую коллекцию.

## 5.4. Итераторы

### 5.4.1. Интерфейс Iterator
Итераторы предоставляют средства для прохода по элементам коллекции. Интерфейс `Iterator` включает методы `hasNext()`, `next()` и `remove()`.

### 5.4.2. Пример использования
```java
List<String> list = new ArrayList<>();
list.add("First");
list.add("Second");
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
```

Итераторы играют ключевую роль в обеспечении безопасного и эффективного доступа к элементам коллекций, особенно при необходимости изменения коллекции во время итерации.

---
# VI. Потоки ввода-вывода (I/O) в Java

Потоки ввода-вывода в Java предназначены для чтения и записи данных. Они могут быть классифицированы как байтовые и символьные потоки, в зависимости от того, работают ли они с байтами или символами.

## 6.1. Байтовые потоки

### 6.1.1. Основы байтовых потоков
Байтовые потоки обеспечивают чтение и запись двоичных данных. Основные классы для работы с байтовыми потоками включают `InputStream` и `OutputStream`.

- `InputStream` используется для чтения данных из источника.
- `OutputStream` предназначен для записи данных в назначение.

### 6.1.2. Чтение и запись с помощью байтовых потоков
Для чтения используется метод `read()`, который читает следующий байт данных. Для записи используется метод `write(int b)`, который записывает указанный байт данных.

```java
try (FileInputStream in = new FileInputStream("input.txt");
     FileOutputStream out = new FileOutputStream("output.txt")) {
    int c;
    while ((c = in.read()) != -1) {
        out.write(c);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

## 6.2. Символьные потоки

### 6.2.1. Основы символьных потоков
Символьные потоки предназначены для работы с текстовыми данными, автоматически обрабатывая преобразование символов в байты и обратно. Основные классы - `Reader` и `Writer`.

- `Reader` используется для чтения текстовых данных.
- `Writer` предназначен для записи текстовых данных.

### 6.2.2. Чтение и запись текстовых данных
Методы `read()` и `write()` в этих классах работают с символами или массивами символов.

```java
try (FileReader reader = new FileReader("input.txt");
     FileWriter writer = new FileWriter("output.txt")) {
    int c;
    while ((c = reader.read()) != -1) {
        writer.write(c);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

## 6.3. Сериализация

### 6.3.1. Понятие сериализации
Сериализация - это процесс преобразования объекта в последовательность байтов для сохранения или передачи данных. Десериализация - обратный процесс, преобразование данных обратно в объект.

### 6.3.2. Реализация сериализации в Java
Для того чтобы объект был сериализуемым, класс должен реализовать интерфейс `Serializable`.

```java
public class User implements Serializable {
    private String name;
    private transient String password; // transient - не сериализуется

    // Конструкторы, геттеры и сеттеры
}
```

### 6.3.3. Сериализация и десериализация объектов
Классы `ObjectOutputStream` и `ObjectInputStream` используются для сериализации и десериализации объектов соответственно.

```java
// Сериализация
try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("user.ser"))) {
    User user = new User("John Doe", "secret");
    out.writeObject(user);
} catch (IOException e) {
    e.printStackTrace();
}

// Десериализация
try (ObjectInputStream in = new ObjectInputStream(new FileInputStream("user.ser"))) {
    User user = (User) in.readObject();
    System.out.println(user.getName());
} catch (IOException | ClassNotFoundException e) {
    e.printStackTrace();
}
```

Важно учитывать, что не все объекты могут быть сериализованы. Объекты классов, не реализующих `Serializable`, вызовут исключение `NotSerializableException`.

---
# VII. Многопоточность в Java

Многопоточность — это способность программы выполнять несколько задач одновременно, используя параллельные потоки выполнения.

## 7.1. Создание потоков

### 7.1.1. Расширение класса Thread
Один из способов создания потока в Java — это расширение класса `Thread` и переопределение его метода `run()`. После создания экземпляра класса поток запускается методом `start()`.

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Поток запущен.");
    }
}

// В основном потоке
MyThread t = new MyThread();
t.start();
```

### 7.1.2. Реализация интерфейса Runnable
Альтернативный способ — реализация интерфейса `Runnable` с последующей передачей его экземпляра в конструктор `Thread`.

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Поток запущен через Runnable.");
    }
}

// В основном потоке
Thread t = new Thread(new MyRunnable());
t.start();
```

### 7.1.3. Выражения Lambda и ExecutorService
С появлением лямбда-выражений в Java 8 создание и запуск потоков стало еще проще, особенно при использовании `ExecutorService` для управления пулом потоков.

```java
ExecutorService executor = Executors.newSingleThreadExecutor();
executor.execute(() -> System.out.println("Поток запущен через ExecutorService"));
executor.shutdown();
```

## 7.2. Синхронизация

### 7.2.1. Ключевое слово synchronized
Для синхронизации доступа к общим ресурсам между потоками используется ключевое слово `synchronized`, которое может применяться к методам и блокам кода.

```java
public synchronized void synchronizedMethod() {
    // Только один поток может выполнять этот код одновременно
}

public void someMethod() {
    synchronized (this) {
        // Синхронизированный блок кода
    }
}
```

### 7.2.2. Вольная блокировка (Lock)
Интерфейс `Lock` из пакета `java.util.concurrent.locks` предлагает более гибкий способ управления блокировками.

```java
Lock lock = new ReentrantLock();
lock.lock();
try {
    // Критическая секция
} finally {
    lock.unlock();
}
```

## 7.3. Взаимодействие потоков

### 7.3.1. Методы wait(), notify() и notifyAll()
Для взаимодействия и синхронизации работы потоков используются методы `wait()`, `notify()` и `notifyAll()`, вызываемые в контексте объектов-мониторов.

```java
public synchronized void producer() throws InterruptedException {
    while (condition) {
        wait(); // Ожидание условия
    }
    // Производство
    notifyAll(); // Уведомление ожидающих потоков
}

public synchronized void consumer() throws InterruptedException {
    while (condition) {
        wait(); // Ожидание условия
    }
    // Потребление
    notifyAll(); // Уведомление ожидающих потоков
}
```

### 7.3.2. Concurrent Collections
Коллекции из пакета `java.util.concurrent`, такие как `ConcurrentHashMap`, предназначены для использования в многопоточных средах и обеспечивают высокую производительность при минимальных затратах на синхронизацию.

### 7.3.3. CompletableFuture
`CompletableFuture` позволяет элегантно работать с асинх

ронными операциями, предоставляя возможность комбинировать их, обрабатывать исключения и реагировать на их завершение.

```java
CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
    System.out.println("Асинхронная задача");
});
future.thenRun(() -> System.out.println("Задача завершена"));
```

Многопоточность в Java позволяет эффективно использовать ресурсы системы, однако требует тщательного управления доступом к общим ресурсам и синхронизации для предотвращения состояний гонки и мертвых блокировок.

---
# VIII. Java Memory Model

Java Memory Model (JMM) определяет, как потоки в Java взаимодействуют через память и что происходит с переменными, которые они читают и пишут. JMM помогает разработчикам понимать многопоточность и обеспечивает основу для `synchronized` блоков, волатильных переменных и конструкций `java.util.concurrent`.

## 8.1. Управление памятью

### 8.1.1. Организация памяти в Java
Память в Java виртуальной машины (JVM) разделена на несколько областей:

- **Куча (Heap)**: Это область памяти, где создаются все объекты классов и массивы. Доступ к этой памяти разделяется между всеми потоками выполнения.
- **Стек (Stack)**: Каждый поток имеет собственный стек, который содержит информацию о вызовах методов и локальных переменных.
- **Метод область (Method Area)**: Здесь хранится код классов, статические переменные и информация о константах.
- **Нативная метод область (Native Method Stack)**: Содержит информацию о нативных методах.

### 8.1.2. Работа с памятью
Java автоматически управляет выделением и освобождением памяти для объектов, что упрощает разработку. Однако разработчикам все еще нужно быть осведомленными о понятиях области видимости объектов и ссылок на них, чтобы избегать утечек памяти.

## 8.2. Garbage Collection

### 8.2.1. Принцип работы Garbage Collection
Garbage Collection (GC) - это процесс автоматического обнаружения и освобождения памяти, которая больше не используется программой. JVM использует различные сборщики мусора, такие как Serial, Parallel, CMS, G1, каждый из которых имеет свои особенности и настройки.

### 8.2.2. Поколения объектов
Объекты в куче делятся на поколения для повышения эффективности сборки мусора:
- **Молодое поколение (Young Generation)**: Сюда попадают новые объекты. Большинство объектов быстро становятся недостижимыми и собираются GC.
- **Старое поколение (Old Generation)**: Объекты, которые долго жили в молодом поколении, перемещаются сюда. Сборка мусора в этом поколении происходит реже.
- **Постоянное поколение (Permanent Generation)** / **Метаспейс (Metaspace)**: Хранит метаданные классов. В Java 8 Metaspace заменил PermGen.

### 8.2.3. Сборка мусора и производительность
GC уменьшает риск утечек памяти, но может влиять на производительность приложения, особенно если сборка мусора происходит слишком часто или занимает много времени. Понимание и настройка работы GC позволяют оптимизировать использование памяти и производительность приложения.

### 8.2.4. Мониторинг и управление GC
Разработчики могут мониторить и управлять процессом сборки мусора с помощью инструментов JVM, так

их как JConsole и VisualVM, а также через опции командной строки, которые позволяют настраивать поведение GC.

Java Memory Model и система управления памятью в Java обеспечивают мощный механизм для эффективного управления ресурсами, автоматической сборки мусора и оптимизации работы приложений. Понимание этих механизмов критически важно для создания производительных и надежных Java-приложений.

---
# IX. Java 8+ Features

С выпуском Java 8 и последующих версий был введен ряд важных нововведений, значительно упрощающих разработку и повышающих эффективность кода.

## 9.1. Лямбда-выражения

### 9.1.1. Что такое лямбда-выражения
Лямбда-выражения в Java — это краткий способ реализации методов из функциональных интерфейсов (интерфейсов с одним абстрактным методом). Лямбда-выражение предоставляет простой синтаксис для создания анонимных методов, позволяя передавать их непосредственно в качестве аргументов методам или присваивать переменным.

### 9.1.2. Синтаксис лямбда-выражений
Основной синтаксис лямбда-выражений выглядит следующим образом:
```java
(parameters) -> expression
```
или
```java
(parameters) -> { statements; }
```
- **parameters**: список параметров, который может быть пустым или содержать один и более параметров.
- **expression**: выражение или блок кода, который выполняется лямбда-выражением.

### 9.1.3. Примеры лямбда-выражений
```java
// Пример без параметров
() -> System.out.println("Hello, World!");

// Пример с одним параметром
(String name) -> System.out.println("Hello, " + name);

// Пример с несколькими параметрами
(int a, int b) -> a + b;

// Пример с блоком кода
(String name) -> {
    String greeting = "Hello, " + name;
    System.out.println(greeting);
};
```

### 9.1.4. Применение лямбда-выражений
Лямбда-выражения часто используются с коллекциями и Stream API для создания компактного и выразительного кода, выполняющего операции фильтрации, преобразования, агрегирования и других действий над данными.

```java
List<String> names = Arrays.asList("John", "Jane", "Doe");
names.forEach(name -> System.out.println(name)); // Итерация и печать каждого элемента списка
```

### 9.1.5. Лямбда-выражения и функциональные интерфейсы
Лямбда-выражения тесно связаны с функциональными интерфейсами в Java. Функциональный интерфейс — это интерфейс с одним абстрактным методом, что делает его совместимым с лямбда-выражениями. Java 8 также представила пакет `java.util.function`, который содержит ряд предопределенных функциональных интерфейсов, таких как `Predicate<T>`, `Function<T,R>`, `Consumer<T>` и `Supplier<T>`.

```java
Function<String, Integer> lengthFunction = s -> s.length();
Integer length = lengthFunction.apply("Hello, World!"); // Возвращает 13
```

### 9.1.6. Выводы
Лямбда-выражения в Java позволяют писать более чистый, модульный и функциональный код, упрощая реализацию интерфейсов и предоставляя мощный инструмент для работы с данными, особенно в сочетании со Stream API.

## 9.2. Stream API

Stream API в Java представляет собой мощный инструмент для работы с коллекциями данных в функциональном стиле. Он позволяет проводить различные операции над элементами коллекции, такие как фильтрация, сортировка, преобразование, агрегация и другие, без необходимости явного управления итерациями и промежуточным хранением результатов.

### 9.2.1. Основы Stream API

#### 9.2.1.1. Создание потоков
Stream можно создать различными способами, в том числе из коллекций или массивов, используя методы `stream()` или `of()`.

```java
Stream<String> stream = Stream.of("a", "b", "c");
Stream<String> collectionStream = Arrays.asList("a", "b", "c").stream();
```

#### 9.2.1.2. Операции над потоками
Операции над потоками данных делятся на промежуточные (intermediate) и терминальные (terminal). Промежуточные операции возвращают новый поток и могут быть связаны в цепочки. Терминальные операции возвращают результат определенного типа или выполняют действие над элементами потока.

### 9.2.2. Промежуточные операции

#### 9.2.2.1. Фильтрация
Метод `filter` принимает предикат и возвращает поток, содержащий только элементы, удовлетворяющие условию предиката.

```java
stream.filter(s -> s.startsWith("a"));
```

#### 9.2.2.2. Преобразование
Метод `map` преобразует каждый элемент потока в другой объект, используя переданную функцию.

```java
stream.map(s -> s.toUpperCase());
```

#### 9.2.2.3. Сортировка
Метод `sorted` используется для сортировки элементов потока. Может принимать компаратор для определения порядка сортировки.

```java
stream.sorted();
```

### 9.2.3. Терминальные операции

#### 9.2.3.1. Проход по элементам
Метод `forEach` выполняет указанное действие для каждого элемента потока.

```java
stream.forEach(System.out::println);
```

#### 9.2.3.2. Сборка в коллекцию
Метод `collect` преобразует поток обратно в коллекцию или другую форму данных.

```java
List<String> list = stream.collect(Collectors.toList());
```

#### 9.2.3.3. Операции агрегации
Методы вроде `count`, `max`, `min`, `sum` и `average` позволяют выполнять агрегатные операции над элементами потока.

```java
long count = stream.count();
```

### 9.2.4. Преимущества и особенности Stream API

- **Ленивая обработка**: многие операции с потоками выполняются лениво, что означает, что они не выполняются до вызова терминальной операции.
- **Параллельное выполнение**: Stream API упрощает обработку данных в параллельном режиме, используя параллельные потоки, что может значительно повысить производительность операций над большими объемами данных.
- **Читаемость кода**: использование Stream API с лямбда-выражениями делает код более читаемым и сокращает его объем.

Stream API является ключевым инструментом для функционального программирования в Java, позволяя разработчикам писать более чистый, модульный и эффективный код.

## 9.3. Нововведения в интерфейсах

Java 8 внесла значительные изменения в работу с интерфейсами, добавив возможность определять методы с реализацией через `default` методы и статические методы в интерфейсах. Эти изменения расширили способы использования интерфейсов в Java, улучшили поддержку функционального программирования и облегчили разработку.

### 9.3.1. Default методы

#### 9.3.1.1. Введение в default методы
Default методы позволяют добавлять новые функции в интерфейсы без нарушения существующих реализаций. Таким образом, можно расширять интерфейсы, сохраняя обратную совместимость.

```java
interface Vehicle {
    default void print() {
        System.out.println("Я транспортное средство!");
    }
}
```

#### 9.3.1.2. Преимущества default методов
- Улучшение обратной совместимости.
- Возможность обеспечения общей реализации для всех наследников интерфейса.
- Поддержка множественного наследования поведения.

#### 9.3.1.3. Использование default методов
Default методы часто используются в коллекциях Java и других утилитах. Например, интерфейс `java.util.List` теперь имеет метод `sort()`, реализованный по умолчанию.

### 9.3.2. Статические методы в интерфейсах

#### 9.3.2.1. Определение статических методов
Java 8 позволяет определять статические методы в интерфейсах. Эти методы можно вызывать непосредственно через имя интерфейса.

```java
interface Vehicle {
    static void blowHorn() {
        System.out.println("Ту-ту!");
    }
}
```

#### 9.3.2.2. Преимущества статических методов
Статические методы в интерфейсах позволяют группировать связанные утилитные методы в одном месте без необходимости создавать отдельный класс-утилиту.

### 9.3.3. Влияние на проектирование и использование

#### 9.3.3.1. Новые шаблоны проектирования
Введение default и статических методов в интерфейсах позволило разработать новые шаблоны проектирования, такие как "виртуальное расширение" и "интерфейсные методы помощники".

#### 9.3.3.2. Множественное наследование поведения
Default методы дают возможность наследовать реализацию от нескольких интерфейсов, обеспечивая форму множественного наследования поведения.

#### 9.3.3.3. Проблемы совместного использования
Несмотря на преимущества, default методы также вносят сложность в разрешение конфликтов, когда два интерфейса предоставляют реализацию по умолчанию для одного и того же метода.

### 9.3.4. Заключение

Нововведения в интерфейсах Java 8 и последующих версий значительно расширили возможности использования интерфейсов, сделав их более мощными и гибкими. Они облегчили процесс разработки и позволили более эффективно использовать функциональные возможности языка, в то же время добавив новые вызовы в управлении наследованием и реализацией интерфейсов.

---